# 插件扩展参数设计与过滤逻辑重构

## 1. 背景与目标

### 1.1 背景

在PanSou搜索系统中，在处理自定义搜索参数（如英文标题搜索）时存在局限性，因为主程序只考虑原始关键词，而不考虑插件可能使用的其他搜索参数。

### 1.2 目标

1. 支持通过`ext`参数向插件传递自定义搜索参数
2. 保持缓存机制的简单高效，ext参数不参与缓存键生成
3. 允许各插件根据自身需求处理ext参数

## 2. 设计方案

### 2.1 插件接口扩展

扩展`SearchPlugin`接口的`Search`方法，添加`ext`参数：

```go
type SearchPlugin interface {
    // Name 返回插件名称
    Name() string
    
    // Search 执行搜索并返回结果
    // ext参数用于传递额外的搜索参数，插件可以根据需要使用或忽略
    Search(keyword string, ext map[string]interface{}) ([]model.SearchResult, error)
    
    // Priority 返回插件优先级（可选，用于控制结果排序）
    Priority() int
}
```

### 2.2 插件实现扩展

#### 2.2.1 普通插件实现

普通插件直接在Search方法中处理ext参数：

```go
// Search 执行搜索并返回结果
func (p *SomePlugin) Search(keyword string, ext map[string]interface{}) ([]model.SearchResult, error) {
    // 直接使用keyword进行搜索，默认忽略ext参数
    // 处理ext参数
    // if ext != nil {
    //     if titleEn, ok := ext["title_en"].(string); ok && titleEn != "" {
    //         keyword = titleEn // 使用英文标题替换关键词
    //     }
    //     // 处理其他自定义参数...
    // }
    
    // 执行搜索逻辑...
    return results, nil
}
```

#### 2.2.2 异步插件实现

异步插件需要修改`doSearch`方法签名，添加ext参数：

```go
// Search 执行搜索并返回结果
func (p *JikepanAsyncV2Plugin) Search(keyword string, ext map[string]interface{}) ([]model.SearchResult, error) {
    // 使用保存的主缓存键，传递ext参数
    return p.AsyncSearch(keyword, p.doSearch, p.MainCacheKey, ext)
}

// doSearch 实际的搜索实现，添加ext参数
func (p *JikepanAsyncV2Plugin) doSearch(client *http.Client, keyword string, ext map[string]interface{}) ([]model.SearchResult, error) {
    // 处理ext参数
    if ext != nil {
        if titleEn, ok := ext["title_en"].(string); ok && titleEn != "" {
            keyword = titleEn // 使用英文标题替换关键词
        }
    }
    
    // 构建请求
    reqBody := map[string]interface{}{
        "name":   keyword,
        "is_all": false,
    }
    
    // 其余搜索逻辑...
    return results, nil
}
```

#### 2.2.3 不使用ext参数的插件

对于不需要使用ext参数的插件，可以简单地忽略该参数：

```go
// Search 执行搜索并返回结果
func (p *SomePlugin) Search(keyword string, ext map[string]interface{}) ([]model.SearchResult, error) {
    // 直接使用keyword进行搜索，忽略ext参数
    // ...
    
    return results, nil
}
```

### 2.3 API层支持

在`api/handler.go`中的`SearchHandler`函数中，添加对`ext`参数的处理：

```go
// 处理ext参数，JSON格式
var ext map[string]interface{}
extStr := c.Query("ext")
if extStr != "" && extStr != " " {
    // 处理特殊情况：ext={}
    if extStr == "{}" {
        ext = make(map[string]interface{})
    } else {
        if err := jsonutil.Unmarshal([]byte(extStr), &ext); err != nil {
            c.JSON(http.StatusBadRequest, model.NewErrorResponse(400, "无效的ext参数格式: "+err.Error()))
            return
        }
    }
}
// 确保ext不为nil
if ext == nil {
    ext = make(map[string]interface{})
}

req = model.SearchRequest{
    Keyword:      keyword,
    Channels:     channels,
    Concurrency:  concurrency,
    ForceRefresh: forceRefresh,
    ResultType:   resultType,
    SourceType:   sourceType,
    Plugins:      plugins,
    Ext:          ext,
}
```

### 2.4 BaseAsyncPlugin 修改

修改`BaseAsyncPlugin.AsyncSearch`方法签名，添加ext参数：

```go
func (p *BaseAsyncPlugin) AsyncSearch(
    keyword string,
    searchFunc func(*http.Client, string, map[string]interface{}) ([]model.SearchResult, error),
    mainCacheKey string,
    ext map[string]interface{},
) ([]model.SearchResult, error) {
    // 确保ext不为nil
    if ext == nil {
        ext = make(map[string]interface{})
    }
    
    // 在调用searchFunc时传递ext参数
    results, err := searchFunc(p.client, keyword, ext)
    // ...其余逻辑保持不变
}
```

## 3. 实施步骤

### 3.1 阶段一：基础架构修改

1. **更新SearchRequest模型**
   - 在`model/request.go`中的`SearchRequest`结构体添加`Ext map[string]interface{}`字段

2. **更新API处理函数**
   - 修改`api/handler.go`中的`SearchHandler`函数，添加ext参数处理
   - 确保在GET和POST两种请求方式下都能正确处理ext参数

3. **修改SearchPlugin接口**
   - 更新`plugin/plugin.go`中的`SearchPlugin`接口，修改`Search`方法签名

4. **修改BaseAsyncPlugin**
   - 更新`plugin/baseasyncplugin.go`中的`AsyncSearch`方法签名和实现
   - 确保在调用searchFunc时传递ext参数

### 3.2 阶段二：插件实现更新

1. **更新普通插件**
   - 修改所有实现`SearchPlugin`接口的普通插件，更新`Search`方法签名

2. **更新异步插件**
   - 修改所有异步插件的`doSearch`方法签名，添加ext参数
   - 更新异步插件的`Search`方法，传递ext参数给`AsyncSearch`

3. **更新SearchService**
   - 修改`service/search_service.go`中的`searchPlugins`方法，传递ext参数给插件

### 3.3 阶段三：测试与优化

1. **单元测试**
   - 为ext参数处理添加单元测试，确保参数正确传递
   - 测试不同类型的ext参数值（字符串、数字、布尔值、数组、对象等）

2. **集成测试**
   - 测试API接口传递ext参数
   - 测试不同插件对ext参数的处理

3. **性能测试**
   - 确保添加ext参数后不影响系统性能
   - 验证缓存机制仍然有效

## 4. 注意事项

### 4.1 缓存键生成

缓存键生成只使用原始关键词，不包含`ext`参数。这是一个有意的设计决策，可以提高缓存命中率，但也意味着使用不同ext参数的搜索可能共享相同缓存。

### 4.2 参数传递

确保ext参数在整个调用链中正确传递，从API层到Service层，再到各个插件实现。

### 4.3 插件兼容性

所有插件都需要更新接口实现，没有向后兼容的考虑，这是一次全面的改造。

## 5. 扩展性考虑

### 5.1 支持更多自定义参数

本设计使用通用的`map[string]interface{}`类型作为`ext`参数，可以灵活支持各种类型的自定义参数，如：

- `title_en`: 英文标题搜索
- `year`: 年份过滤
- `category`: 分类过滤
- `quality`: 质量过滤（如1080p、4K等）

### 5.2 插件特定参数

不同插件可以根据自身特点支持不同的自定义参数，主程序不需要了解这些参数的具体含义，只负责传递。

## 6. 示例实现

### 6.1 SearchRequest 模型更新

```go
// SearchRequest 搜索请求参数
type SearchRequest struct {
    Keyword      string                 `json:"kw" binding:"required"`
    Channels     []string               `json:"channels"`
    Concurrency  int                    `json:"conc"`
    ForceRefresh bool                   `json:"refresh"`
    ResultType   string                 `json:"res"`
    SourceType   string                 `json:"src"`
    Plugins      []string               `json:"plugins"`
    Ext          map[string]interface{} `json:"ext"`
}
```

### 6.2 异步插件实现示例

```go
package myplugin

import (
    "pansou/model"
    "pansou/plugin"
)

// MyAsyncPlugin 自定义异步插件
type MyAsyncPlugin struct {
    *plugin.BaseAsyncPlugin
}

// Search 实现搜索接口
func (p *MyAsyncPlugin) Search(keyword string, ext map[string]interface{}) ([]model.SearchResult, error) {
    // 使用保存的主缓存键，传递ext参数
    return p.AsyncSearch(keyword, p.doSearch, p.MainCacheKey, ext)
}

// doSearch 执行实际搜索
func (p *MyAsyncPlugin) doSearch(client *http.Client, keyword string, ext map[string]interface{}) ([]model.SearchResult, error) {
    // 处理ext参数
    if ext != nil {
        if titleEn, ok := ext["title_en"].(string); ok && titleEn != "" {
            keyword = titleEn // 使用英文标题
        }
        
        // 其他自定义参数处理...
    }
    
    // 实现搜索逻辑
    // ...
    
    return results, nil
}
```

### 6.3 实际应用示例：jikepan_ext插件

jikepan_ext插件是一个实际应用ext参数的例子，它使用ext中的title_en参数来替代原始关键词进行搜索：

```go
// doSearch 实际的搜索实现
func (p *JikepanAsyncV2Plugin) doSearch(client *http.Client, keyword string, ext map[string]interface{}) ([]model.SearchResult, error) {
    // 构建请求
    reqBody := map[string]interface{}{
        "name":   keyword,
        "is_all": false,
    }
    
    // 检查ext中是否包含title_en参数，如果有则使用它
    if ext != nil {
        if titleEn, ok := ext["title_en"].(string); ok && titleEn != "" {
            // 使用title_en替换或补充keyword
            reqBody["name"] = titleEn
        }
    }
    
    jsonData, err := json.Marshal(reqBody)
    if err != nil {
        return nil, fmt.Errorf("marshal request failed: %w", err)
    }
    
    // 后续搜索逻辑...
}
```

这个实现允许客户端通过ext参数传递英文标题，例如：

```
GET /api/search?kw=火影忍者&ext={"title_en":"Naruto"}
```

在这个请求中，jikepan_ext插件将使用"Naruto"而不是"火影忍者"作为搜索关键词，这对于搜索外文资源特别有用。

## 7. 使用示例

### 7.1 API请求示例

#### GET请求

```
GET /api/search?kw=火影忍者&ext={"title_en":"Naruto","year":2002}
```

#### POST请求

```json
POST /api/search
{
  "kw": "火影忍者",
  "ext": {
    "title_en": "Naruto",
    "year": 2002,
    "quality": "1080p"
  }
}
```

### 7.2 客户端使用示例

```javascript
// 使用fetch API发送带ext参数的请求
async function search(keyword, ext) {
  const params = new URLSearchParams();
  params.append('kw', keyword);
  if (ext) {
    params.append('ext', JSON.stringify(ext));
  }
  
  const response = await fetch(`/api/search?${params}`);
  return await response.json();
}

// 使用示例
search('火影忍者', { title_en: 'Naruto', year: 2002 })
  .then(results => {
    console.log(results);
  });
```
